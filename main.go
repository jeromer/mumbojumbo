package main

import (
	"bytes"
	"flag"
	"fmt"
	"math/rand"
	"os"
	"strings"
	"text/template"
	"time"
	"unsafe"
)

const (
	VERSION = "1.1"
)

var (
	s = flag.String("s", "", "string to obfuscate")
	p = flag.String("p", "", "pkg name for the generated code")
)

var (
	tpl = `// CODE GENERATED BY mumbojumbo {{ .Version }} (https://github.com/jeromer/mumbojumbo) DO NOT EDIT !!!!

package {{ .Pkg }}

import (
	"unsafe"
)

func eax() uint8{
	return uint8(unsafe.Sizeof(true))
}

func Get() string {
{{ .Obfuscated }}
}
`
)

func main() {
	flag.Parse()

	if *s == "" {
		quit("no string provided")
	}

	if *p == "" {
		quit("no pkg provided")
	}

	fmt.Println(
		generateGoCode(
			tplData{
				Version:    VERSION,
				Pkg:        *p,
				Obfuscated: obfuscate(*s),
			},
		),
	)
}

// ----

type tplData struct {
	Version    string
	Pkg        string
	Obfuscated string
}

func generateGoCode(data tplData) string {
	tmpl := template.Must(
		template.New("x").Parse(tpl),
	)

	w := new(bytes.Buffer)
	err := tmpl.Execute(w, data)

	if err != nil {
		panic(err)
	}

	return w.String()
}

// ----

// shamefully taken from
// https://github.com/GH0st3rs/obfus/blob/master/obfus.go

const (
	EAX = uint8(unsafe.Sizeof(true))
	ONE = "eax()"
)

func obfuscate(txt string) string {
	lines := []string{}

	for _, item := range []byte(txt) {
		lines = append(
			lines, getNumber(item),
		)
	}

	return fmt.Sprintf(
		"return string(\n[]byte{\n%s,\n},\n)",
		strings.Join(lines, ",\n"),
	)
}

func getNumber(n byte) (buf string) {
	var arr []byte
	var x uint8

	for n > EAX {
		x = 0

		if n%2 == EAX {
			x = EAX
		}

		arr = append(arr, x)

		n = n >> EAX
	}

	buf = ONE

	rand.Seed(
		time.Now().Unix(),
	)

	for i := len(arr) - 1; i >= 0; i-- {
		buf = fmt.Sprintf(
			"%s<<%s", buf, ONE,
		)

		if arr[i] == EAX {
			op := "(%s|%s)"

			if rand.Intn(2) == 0 {
				op = "(%s^%s)"
			}

			buf = fmt.Sprintf(
				op, buf, ONE,
			)
		}
	}

	return buf
}

func quit(msg string) {
	fmt.Println(msg)
	os.Exit(1)
}
